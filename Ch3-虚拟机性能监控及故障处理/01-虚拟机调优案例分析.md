# 虚拟机调优案例分析

<!-- TOC -->

- [虚拟机调优案例分析](#虚拟机调优案例分析)
    - [高性能硬件上的程序部署策略](#高性能硬件上的程序部署策略)
    - [除了 Java 堆和永久代之外，会占用较多内存的区域](#除了-java-堆和永久代之外会占用较多内存的区域)
    - [仅从 GC 调优角度解决新生代存活大量对象的问题](#仅从-gc-调优角度解决新生代存活大量对象的问题)

<!-- /TOC -->

## 高性能硬件上的程序部署策略

![高性能硬件上的程序部署策略.png](./pic/高性能硬件上的程序部署策略.png)



> **补充：64 位虚拟机**
>
> 在 Java EE 方面，企业级应用经常需要使用超过 4GB 的内存，此时，32 位虚拟机将无法满足需求，可是 64 位虚拟机虽然可以设置更大的内存，却存在以下缺点：
>
> - **内存问题：** 由于指针膨胀和各种数据类型对齐补白的原因，运行于 64 位系统上的 Java 应用程序需要消耗更多的内存，通常要比 32 位系统额外增加 10% ~ 30% 的内存消耗。
> - **性能问题：** 64 位虚拟机的运行速度在各个测试项中几乎全面落后于 32 位虚拟机，两者大概有 15% 左右的性能差距。



## 除了 Java 堆和永久代之外，会占用较多内存的区域

| 区域          | 大小调整 / 说明                                             | 内存不足时抛出的异常                                         |
| ------------- | ----------------------------------------------------------- | ------------------------------------------------------------ |
| 直接内存      | `-XX:MaxDirectMemorySize`                                   | OutOfMemoryError: Direct buffer memory                       |
| 线程堆栈      | `-Xss`                                                      | StackOverflowError 或 OutOfMemoryError: unable to create new native thread |
| Socket 缓存区 | 每个 Socket 连接都有 Receive(37KB) 和 Send(25KB) 两个缓存区 | IOException: Too many open files                             |
| JNI 代码      | 如果代码中使用 JNI 调用本地库，那本地库使用的内存也不在堆中 |                                                              |
| 虚拟机和 GC   | 虚拟机、GC 代码执行要消耗一定内存                           |                                                              |



## 仅从 GC 调优角度解决新生代存活大量对象的问题

- 将 Survivor 空间去除，让新生代中存活的对象在第一次 Minor GC 后立刻进入老年代，等到 Full GC 时再清理。
- 参数调整方法：
	- `-XX:SurvivorRatio=65536`
	- `-XX:MaxTenuringThreshold=0`
	- `-XX:AlwaysTenure`