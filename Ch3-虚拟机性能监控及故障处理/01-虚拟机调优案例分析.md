# 虚拟机调优案例分析

<!-- TOC -->

- [虚拟机调优案例分析](#虚拟机调优案例分析)
    - [高性能硬件上的程序部署策略](#高性能硬件上的程序部署策略)
    - [除了 Java 堆和永久代之外，会占用较多内存的区域](#除了-java-堆和永久代之外会占用较多内存的区域)
    - [仅从 GC 调优角度解决新生代存活大量对象的问题](#仅从-gc-调优角度解决新生代存活大量对象的问题)

<!-- /TOC -->

## 高性能硬件上的程序部署策略

![高性能硬件上的程序部署策略.png](./pic/高性能硬件上的程序部署策略.png)



## 除了 Java 堆和永久代之外，会占用较多内存的区域

| 区域          | 大小调整 / 说明                                             | 内存不足时抛出的异常                                         |
| ------------- | ----------------------------------------------------------- | ------------------------------------------------------------ |
| 直接内存      | `-XX:MaxDirectMemorySize`                                   | OutOfMemoryError: Direct buffer memory                       |
| 线程堆栈      | `-Xss`                                                      | StackOverflowError 或 OutOfMemoryError: unable to create new native thread |
| Socket 缓存区 | 每个 Socket 连接都有 Receive(37KB) 和 Send(25KB) 两个缓存区 | IOException: Too many open files                             |
| JNI 代码      | 如果代码中使用 JNI 调用本地库，那本地库使用的内存也不在堆中 |                                                              |
| 虚拟机和 GC   | 虚拟机、GC 代码执行要消耗一定内存                           |                                                              |



## 仅从 GC 调优角度解决新生代存活大量对象的问题

- 将 Survivor 空间去除，让新生代中存活的对象在第一次 Minor GC 后立刻进入老年代，等到 Full GC 时再清理。
- 参数调整方法：
	- `-XX:SurvivorRatio=65536`
	- `-XX:MaxTenuringThreshold=0`
	- `-XX:AlwaysTenure`