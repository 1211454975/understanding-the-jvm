# 虚拟机的类加载机制



## 类加载的时机

JVM 会在程序第一次主动引用类的时候，加载该类，被动引用时并不会引发类加载的操作。也就是说，JVM 并不是在一开始就把一个程序就所有的类都加载到内存中，而是到不得不用的时候才把它加载进来，而且只加载一次。那么什么是主动引用，什么是被动引用呢？

- **主动引用**
	- 遇到 new、getstatic、putstatic、invokestatic 字节码指令，例如：
		- 使用 new 实例化对象；
		- 读取或设置一个类的 static 字段（被 final 修饰的除外）；
		- 调用类的静态方法。
	- 对类进行反射调用；
	- 初始化一个类时，其父类还没初始化（需先初始化父类）；
		- 这点类与接口具有不同的表现，接口初始化时，不要求其父接口完成初始化，只有真正使用父接口时才初始化，如引用父接口中定义的常量。
	- 虚拟机启动，先初始化包含 main() 函数的主类；
	- JDK 1.7 动态语言支持：一个 java.lang.invoke.MethodHandle 的解析结果为 REF_getStatic、REF_putStatic、REF_invokeStatic。
- **被动引用**
	- 通过子类引用父类静态字段，不会导致子类初始化；
	- `Array[] arr = new Array[10];` 不会触发 Array 类初始化；
	- `static final VAR` 在编译阶段会存入调用类的常量池，通过 `ClassName.VAR` 引用不会触发 ClassName 初始化。

也就是说，只有发生主动引用所列出的 5 种情况，一个类才会被加载到内存中，也就是说类的加载是 lazy-load 的，不到必要时刻是不会提前加载的，毕竟如果将程序运行中永远用不到的类加载进内存，会占用方法区中的内存，浪费系统资源。

> **P.S. 数组类的初始化**
>
> - 数组类的创建由 Java 虚拟机完成；
> - 创建动作由 newarray 指令触发；
> - new 实际上触发了 `[L全类名` 对象的初始化。



## 类加载的过程

### 类的生命周期

```
加载 --> 验证 --> 准备 --> 解析 --> 初始化 --> 使用 --> 卸载
       |<------- 连接 ------->|
|<------------- 类加载 ---------------->|
```

类的生命周期一共有 7 个阶段，其中前五个阶段较为重要，统称为类加载，第 2 ~ 4 阶段统称为连接，加载和连接中的三个过程开始的顺序是固定的，但是执行过程中是可以交叉执行的。





## 类加载器