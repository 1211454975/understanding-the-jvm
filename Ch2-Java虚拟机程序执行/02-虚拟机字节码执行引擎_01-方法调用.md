# 方法调用

Java 的方法的执行分为两个部分：

- 方法调用：确定被调用的方法是哪一个；
- 基于栈的解释执行：真正的执行方法的字节码。

在本节中我们将对方法调用进行详细的讲解，我们知道，一切方法的调用在 Class 文件中存储的都是常量池中的符号引用，而不是方法实际运行时的入口地址（直接引用），直到类加载的时候，甚至是实际运行的时候才回去会去确定要被运行的方法的直接引用，而确定要被运行的方法的直接引用的过程就叫做方法调用。



## 方法调用字节码指令

Java 虚拟机提供了 5 个职责不同的方法调用字节码指令：

- `invokestatic`：调用静态方法；
- `invokespecial`：调用构造器方法、私有方法、父类方法；
- `invokevirtual`：调用所有虚方法，除了静态方法、构造器方法、私有方法、父类方法、final 方法的其他方法叫虚方法；
- `invokeinterface`：调用接口方法，会在运行时确定一个该接口的实现对象；
- `invokedynamic`：在运行时动态解析出调用点限定符引用的方法，再执行该方法。

除了 `invokedynamic`，其他 4 种方法的第一个参数都是被调用的方法的符号引用，是在编译时确定的，所以它们缺乏动态类型语言支持，因为动态类型语言只有在运行期才能确定接收者的类型，即变量的类型检查的主体过程在运行期，而非编译期。

> final 方法虽然是通过 `invokevirtual` 调用的，但是其无法被覆盖，没有其他版本，无需对接收者进行多态选择，或者说多态选择的结果是唯一的，所以属于非虚方法。



## 解析调用

解析调用，正如其名，就是在类加载的解析阶段，就确定了方法的调用版本。我们知道类加载的解析阶段会将一部分符号引用转化为直接引用，这一过程就叫做解析调用。因为是在程序真正运行前就确定了要调用哪一个方法，所以 **解析调用能成立的前提就是：方法在程序真正运行前就有一个明确的调用版本了，并且这个调用版本不会在运行期发生改变。**

符合这两个要求的只有以下两类方法：

- 通过 `invokestatic` 调用的方法：静态方法；
- 通过 `invokespecial` 调用的方法：私有方法、构造器方法、父类方法；

这两类方法根本不可能通过继承或者别的方式重写出来其他版本，也就是说，在运行前就可以确定调用版本了，十分适合在类加载阶段就解析好。它们会在类加载的解析阶被解析为直接引用，即确定调用版本。



## 分派调用

在介绍分派调用前，我们先来介绍一下 Java 所具备的面向对象的 3 个基本特征：封装，继承，多态。

其中多态最基本的体现就是重载和重写了，重载和重写的一个重要特征就是方法名相同，其他各种不同：

- 重载：发生在同一个类中，入参必须不同，返回类型、访问修饰符、抛出的异常都可以不同；
- 重写：发生在子父类中，入参和返回类型必须相同，访问修饰符大于等于被重写的方法，不能抛出新的异常。

相同的方法名实际上给虚拟机的调用带来了困惑，因为虚拟机需要判断，它到底应该调用哪个方法，而这个过程会在分派调用中体现出来。其中：

- 方法重载 —— 静态分派
- 方法重写 —— 动态分派


### 静态分派（方法重载）

在介绍静态分派前，我们先来介绍一下什么是变量的静态类型和实际类型。

#### 变量的静态类型和实际类型

```java
public class StaticDispatch {
    static abstract class Human {
    }

    static class Man extends Human {
    }

    static class Woman extends Human {
    }

    public void sayHello(Human guy) {
    	System.out.println("Hello guy!");
    }

    public void sayHello(Man man) {
    	System.out.println("Hello man!");
    }

    public void sayHello(Woman woman) {
    	System.out.println("Hello woman!");
    }

    public static void main(String[] args) {
        Human man = new Man();
        Human woman = new Woman();
        StaticDispatch sr = new StaticDispatch();
        sr.sayHello(man);
        sr.sayHello(woman);
        /* 输出：
        Hello guy!
        Hello guy!
        因为是根据变量的静态类型，也就是左面的类型：Human 来判断调用哪个方法，
        所以调用的都是 public void sayHello(Human guy)
        */
    }
}

/* 简单讲解 */
// 使用
Human man = new Man();

// 实际类型发生变化
Human man = new Man();
man = new Woman();

// 静态类型发生变化
sr.sayHello((Man) man);
sr.sayHello((Woman) man);
```

其中 `Human` 称为变量的静态类型，`Man` 称为变量的实际类型。

在重载时，编译器是通过方法参数的静态类型，而不是实际类型，来判断应该调用哪个方法的。

#### 重载方法匹配优先级，例如一个字符 'a' 作为入参

- 基本类型
	- char
	- int
	- long
	- float
	- double
- Character
- Serializable（Character 实现的接口）
	- 同时出现两个优先级相同的接口，如 Serializable 和 Comparable，会提示类型模糊，拒绝编译。
- Object
- char...（变长参数优先级最低）

### 动态分派（方法重写）

动态分派就是在运行时，根据实际类型确定方法执行版本的分派过程。

#### 动态分派的过程

我们先来看一个例子：

```java
public class DynamicDispatch {
    static abstract class Human {
  	  protected abstract void sayHello();
    }

    static class Man extends Human {
        protected void sayHello() {
        	System.out.println("Hello man");
        }
    }

    static class Woman extends Human {
        protected void sayHello() {
        	System.out.println("Hello woman");
        }
    }

    public static void main(String[] args) {
        Human man = new Man();
        Human woman = new Woman();
        man.sayHello();
        woman.sayHello();
        man = woman;
        man.sayHello();
        /* 输出
        Hello man
        Hello woman
        Hello woman
        */
    }
}
```

字节码分析：

```
public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
        stack=2, locals=3, args_size=1
        0: new           #2      // class com/jvm/ch8/DynamicDispatch$Man
        3: dup
        4: invokespecial #3      // Method com/jvm/ch8/DynamicDispatch$Man."<init>":()V
        7: astore_1
        8: new           #4      // class com/jvm/ch8/DynamicDispatch$Woman
        11: dup
        12: invokespecial #5     // Method com/jvm/ch8/DynamicDispatch$Woman."<init>":()V
        15: astore_2
        16: aload_1		        // 把刚创建的对象的引用压到操作数栈顶，
        					   // 供之后执行sayHello时确定是执行哪个对象的sayHello
        17: invokevirtual #6    // 方法调用
        20: aload_2             // 把刚创建的对象的引用压到操作数栈顶，
                                // 供之后执行sayHello时确定是执行哪个对象的sayHello
        21: invokevirtual #6    // 方法调用
        24: aload_2
        25: astore_1
        26: aload_1
        27: invokevirtual #6    // Method com/jvm/ch8/DynamicDispatch$Human.sayHello:()V
        30: return
```

通过字节码分析可以看出，`invokevirtual` 指令的运行过程大致为：

- 去操作数栈顶取出将要执行的方法的所有者，记作 C；
- 查找此方法：
	- 在 C 中查找此方法；
	- 在 C 的各个父类中查找；
	- 查找过程：
		- 查找与常量的描述符和简单名称都相同的方法；
		- 进行访问权限验证，不通过抛出：IllegalAccessError 异常；
		- 通过访问权限验证则返回直接引用；
- 没找到则抛出：AbstractMethodError 异常，即该方法没被实现。

#### 动态分派的实现

动态分派在虚拟机种执行的非常频繁，而且方法查找的过程要在类的方法元数据中搜索合适的目标，从性能上考虑，不太可能进行如此频繁的搜索，需要进行性能上的优化。

**常用优化手段：** 在类的方法区中建立一个虚方法表。

- 虚方法表中存放着各个方法的实际入口地址，如果某个方法没有被子类方法重写，那子类方法表中该方法的入口地址 = 父类方法表中该方法的入口地址；
- 使用这个方法表索引代替在元数据中查找；
- 该方法表会在类加载的连接阶段初始化好。

> 总结一下：静态分派看左面，动态分派看右面。

### 单分派与多分派

除了静态分派和动态分派这种分派分类方式，还有一种根据宗量分类的方式，可以将方法分派分为单分派和多分派。

> 宗量：方法的接收者 & 方法的参数。

Java 语言的静态分派属于多分派，根据 **方法接收者的静态类型** 和 **方法参数类型** 两个宗量进行选择。

Java 语言的动态分派属于单分派，只根据 **方法接收者的实际类型** 一个宗量进行选择。



## 动态类型语言支持

**什么是动态类型语言？** 就是类型检查的主体过程在运行期，而非编译期的编程语言。

**动/静态类型语言各自的优点？**

- 动态类型语言：灵活性高，开发效率高。
- 静态类型语言：编译器提供了严谨的类型检查，类型相关的问题能在编码的时候就发现。

**Java虚拟机层面提供的动态类型支持：**

- `invokedynamic` 指令
- java.lang.invoke 包

### java.lang.invoke 包

**目的：** 在之前的依靠符号引用确定调用的目标方法的方式之外，提供了 MethodHandle 这种动态确定目标方法的调用机制。

#### MethodHandle 的使用



#### MethodHandle 和 Reflection 的区别



### `invokedynamic` 指令